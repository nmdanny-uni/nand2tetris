class TetrisPiece {

  // A matrix of shapes, each row represents a different shape,
  // and each column represents a different rotation of shape. Going right in the matrix gives you
  // a clockwise rotation, and left gives you the counter-clockwise rotation (wrapping around the row
  // if necessary)
  //
  static Array shapes;

  // Each shape encoded via an int, a 16 bit number, which can be thought as a
  // 4x4 grid of squares.
  // For example, the shape that looks like so (a 2x2 square)
  //  1100
  //  1100
  //  0000
  //  0000
  //
  // represented in binary: 0000000000110011
  // or, as int16(2s complement): 51
  //
  // Note how we build the binary number, starting with the LSB, from left to right top to bottom
  // This also gives us the mapping between bit indices to coordinates, for example
  // bit 0: (0, 0) (LSB)
  // bit 1: (1, 0)
  // bit 3: (3, 0)
  // bit 4: (0, 1)
  // and so on...
  field int shapeEncoding;

  // coordinate of the topleft corner of the shape grid, within the TetrisBoard grid
  field int tlX;
  field int tlY;

  constructor TetrisPiece new(int setShapeEncoding, int x, int y){
    let shapeEncoding = setShapeEncoding;
    let tlX = x;
    let tlY = y;
    return this;
  }

  function TetrisPiece getRandomPiece() {
    var TetrisPiece piece;
    let piece = TetrisPiece.new(shapes[3], 5, 0);
    return piece;
  }

  /** This initializes all available shapes. Must be ran at the beginning of the program */
  function void initShapes() {
    // 7 shapes, each has 4 rotations
    let shapes = Arary.new(7 * 4);
    // the following were generated by a short python program
    let shapes[0] = 8738;
    let shapes[1] = 240;
    let shapes[2] = 17476;
    let shapes[3] = 3840;
    let shapes[4] = 802;
    let shapes[5] = 113;
    let shapes[6] = 1100;
    let shapes[7] = 1136;
    let shapes[8] = 1570;
    let shapes[9] = 368;
    let shapes[10] = 547;
    let shapes[11] = 116;
    let shapes[12] = 51;
    let shapes[13] = 51;
    let shapes[14] = 51;
    let shapes[15] = 51;
    let shapes[16] = 864;
    let shapes[17] = 561;
    let shapes[18] = 54;
    let shapes[19] = 1122;
    let shapes[20] = 624;
    let shapes[21] = 562;
    let shapes[22] = 114;
    let shapes[23] = 610;
    let shapes[24] = 1584;
    let shapes[25] = 306;
    let shapes[26] = 99;
    let shapes[27] = 612;
    return;
  }

  /** Returns the occupied coordinates as a 4*2 matrix, where the first column
      contains 'x' and the second column contains 'y' component of the coordinate
      (using row-major ordering)
  */
  method Array getOccupiedCoordinates() {
    var Array array;
    var int arrayIx, row, col;
    let array = Array.new(8);

    let arrayIx = 0;
    let row = 0;
    while (row < 4) {
      let col = 0;
      while (col < 4){
        // using the mapping mentioned before, we add the coordinate
        // to the output array if the corresponding bit is set
        if (Util.getBit(shapeEncoding, (row * 4) + col)) {
          let array[arrayIx] = tlX + col;
          let array[arrayIx+1] = tlY + row;
          let arrayIx = arrayIx + 2;
        }
        let col = col + 1;
      }
      let row = row + 1;
    }

    return array;
  }

  /** Getters and setters for X,Y coordinates of the top-left
      corner of the shape
  */

  method int getTopLeftX() {
    return tlX;
  }

  method int getTopLeftY() {
    return tlY;
  }

  method void setTopLeftCoordinates(int newX, int newY) {
    let tlX = newX;
    let tlY = newY;
    return;
  }

  /** Draws the piece to the given board (if active), or un-draws it (if inactive)
  */
  method void draw(TetrisBoard board, boolean active) {
    var Array occupied;
    var int i;
    let occupied = getOccupiedCoordinates();
    let i = 0;
    while (i < 4) {
      do board.setActive(occupied[i*2], occupied[(i*2) + 1], active);
      let i = i + 1;
    }
    do occupied.dispose();
    return;
  }

  method void dispose(){
    do Memory.deAlloc(this);
    return;
  }
}
