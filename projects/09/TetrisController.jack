/* This class is responsible for driving the game, by handling keyboard inputs
   and drawing to screen according to the current state of the game.
*/
class TetrisController {

  // used to draw squares on screen
  field TetrisBoard board;

  // either 0(a null pointer) if the game hasn't started, otherwise a valid Piece object.
  field TetrisPiece currentPiece;

  // current score
  field int score;

  /* Starts a new game, responsible for initializing relevant fields
  */
  method void startGame() {
    do Output.moveCursor(0, 0);
    do Screen.clearScreen();

    if (~(board = 0)) {
      do board.dispose();
    }
    let board = TetrisBoard.new();
    let score = 0;
    do board.draw();
    do createNewPiece();
    return;
  }

  constructor TetrisController new(){
    return this;
  }

  method void dispose() {
    do board.dispose();
    do currentPiece.dispose();
    do Memory.deAlloc(this);
    return;
  }

  /** Processes player inputs. To be ran every tick during
      the game, this returns whether the game should continue running,
      returns false when restarting/quitting/losing, otherwise true.
  */
  method boolean processInput() {
    var boolean wentDown, lost;
    if (Keyboard.keyPressed() = 81) { // Q button
      do GameScreens.showQuittingScreen(score);
      return false;
    }

    if (Keyboard.keyPressed() = 82) { // R button
      do GameScreens.showRestartScreen(score);
      return false;
    }
    if (Keyboard.keyPressed() = 130) { // left-arrow
      do currentPiece.move(board, -1, 0);
    }
    if (Keyboard.keyPressed() = 132) { // right-arrow
      do currentPiece.move(board, 1, 0);
    }
    if (Keyboard.keyPressed() = 131) { // up-arrow
      do currentPiece.rotate(board);
    }
    if (Keyboard.keyPressed() = 133) { // down-arrow
      let wentDown = currentPiece.move(board, 0, 1);
      if (~wentDown) {
        let lost = ~placePiece();
        if (lost) {
          do GameScreens.showLoseScreen(score);
          return false;
        }
      }
    }
    return true;
  }

  /** Tries creating a new tetris piece and draws it on the board
      Returns false if there's no space for the new piece (loss condition)
  */
  method boolean createNewPiece() {
    if (~(currentPiece = 0)) {
      do currentPiece.dispose();
    }
    let currentPiece = TetrisPiece.new(
                                       Util.getNumberInRange(0, 7),
                                       Util.getNumberInRange(0, 4),
                                       3, 0);
    if (~currentPiece.isNotColliding(board)) {
      return false;
    }
    do currentPiece.draw(board, true);
    return true;
  }

  /** Places the current piece on the map, and creates a new piece,
      returning whether it succeeded in placing it. (false indicates a loss condition)
  */
  method boolean placePiece() {
    // occupiedSquares is a 4x2 matrix, first col for 'x' coords and second for 'y'
    var Array occupiedSquares;
    var int xCord, yCord;
    var int yMin; // this includes the topmost(minimal) y-coordinate of the shape
    var int coordIx;
    let coordIx = 0;
    let yMin = 9999;
    let occupiedSquares = currentPiece.getOccupiedCoordinates();
    while (coordIx < 4) {
      let xCord = occupiedSquares[coordIx * 2];
      let yCord = occupiedSquares[(coordIx * 2) + 1];
      let yMin = Math.min(yMin, yCord);
      do board.setMode(xCord, yCord, 2); // mode 2 = placed block
      let coordIx = coordIx + 1;
    }
    do clearLines(yMin);
    return createNewPiece();
  }

  /** Clears up to 4 lines of blocks, beginning from the given row,
      and going down up.
  */
  method void clearLines(int startRow) {
    var int numLinesCleared;
    var int y;
    let numLinesCleared = 0;
    let y = startRow;
    while ((y < TetrisBoard.getNumRows()) & (y < (startRow + 4))) {
      if (board.isLineFull(y)) {
        do board.clearLine(y);
      }
      let y = y + 1;
    }
    return;
  }

  /** The main entry point, responsible for running the game
  */
  method void gameLoop() {
    var boolean continuePlaying;

    // only ran once in the program's lifetime
    do GameScreens.showStartScreen();
    while (true) {
      do startGame();
      let continuePlaying = true;

      // the following loop occurs within a single game
      while (continuePlaying) {
        let continuePlaying = processInput();
        do Sys.wait(getTickDelayMs());
      }

    }
    return;
  }


  /** Number of milliseconds between each game tick */
  method int getTickDelayMs() {
    return 100;
  }
}
